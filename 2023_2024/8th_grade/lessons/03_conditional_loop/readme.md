# לולאה מותנה (while)

## האתגר - משחק ניחושים

כללי המשחק:
- שחקן 1 בוחר מספר בין אחת ל1000
- לשחקן 2 יש 10 ניחושים למצוא את המספר
- בכל ניחוש שחקן 1 רק עונה האם הניחוש שווה למספר, גדול מהמספר או קטן מהמספר


## מימוש 
כדי לממש את הפתרון בו המחשב הוא שחקן 2, נצטרך להשתמש בלולאה מותנה:
![image](https://github.com/weiss-gal/data_science_project/assets/8408299/04994c45-da7f-4773-b780-dbff8b5b843a)

למי שלא זוכר, או לא היה, הנה סרטון על לולאה מותנית (while loop): 
[לולאת תנאי](https://www.youtube.com/watch?v=dIabSSSo6FQ&list=PLi5wNsn0QX4hAgdAqawlYt5_v_CoX6Q1n&index=23)

## הצעה לצעדים למימוש
1 שמירת ערכי מינימום ומקסימום: בכל זמן נתון אנחנו יודעים שהמספר שהמשתמש בחר נמצא בין שני מספרים, ניצור שני משתנים כדי לשמור את המינימום והמקסימום שהמשתמש בחר (שאלה: מאיזה ערכים נתחיל)
  - טיפ: בדרך כלל שם משתנה מוצלח יהיה min וmax, הבעיה שאלה שתי פקודות קיימות בפייתון, ולכן אם נשתמש בהן ניצור בלאגן לא קטן. לכן אני ממליץ על שמות טיפה שונים אבל עדיין עם משמעות - למשל mn וmx או min_val וmax_val.
2 חישוב ערך האמצע: בכל פעם שנרצה "לנחש" מספר, הוא יהיה המספר בין המינימום למקסימום. לכן עלינו לחשב את הערך שנמצא בין מינימום למקסימום, חשבו אותו והציבו במשתנה חדש
  - טיפ: שימו לב שכאשר אתם מחלקים שני מספרים, התוצאה מבחינת פייתון היא תמיד מספר לא-שלם (float) בניגוד למספר שלם (int). לצורך המשחק, אנחנו רוצים תמיד לעבוד במספרים שלמים, גם אם זה לא בדיוק האמצע, לצורך זה אנחנו יכולים לעשות אחד משני דברים: אפשרות ראשונה, להשתמש באופרטור (פעולה) החלוקה // במקום /, ההבדל הוא שאופרטור // תמיד יעגל את התוצאה מטה, למספר השלם הכי קרוב. אפשרות שנייה להשתמש בפקודה int, שתנסה להמיר ערכים מסוג אחר לערכים שהם מספר שלם, דוגמאות:
  - 
![image](https://github.com/weiss-gal/data_science_project/assets/8408299/b04438fb-28fc-4dcf-8933-3d15ec9e8a20)

3 נציג למשתמש את הניחוש (שחישבנו בסעיף קודם) ונשאל אותו (על ידי הפקודה input), האם הערך שהוא חשב עליו שווה, גדול או קטן יותר. כדי לפשט את העניין זה בסדר אם המשתמש יענה בסימן אחד:
  - סימן "שווה" *=* כאשר הערך שבחר המחשב שווה למה שחשב עליו המשתמש.
  - סימן "גדול" *<* כאשר הערך שבחר המשתמש יותר גדול מהערך שבחר המחשב
  - סימו "קטן" *>* כאשר הערך שבחר המשתמש יותר קטן מהערך שבחר המחשב
4 בהתאם לפידבק מהמשתמש, נעדכן את ה"גבולות" שלנו.
  - אם קיבלנו = - יאי, הצלחנו !
  - אם קיבלנו < נזיז את הגבול המינמלי להיות הניחוש שלנו (כי אנחנו יודעים שהמספר מעליו)
  - אם קיבלנו > נזיז את הגבול המקסימלי להיות הניחוש שלנו (אי אנחנו יודעים שהמספר מתחתיו)
5 נחזור על צערים 2 עד 4 - בשלב זה רק נדפיס את הגבולות
6 אם עשינו הכל טוב עד עכשיו, כל מה שצריך זה לעטוף את צעדים 2 עד 4 בלולאה.
  - מתי הלולאה מסתיימת ? הפתרון הכי פשוט כנראה יהיה לעשות לולאה שרצה לנצח (while True, זוכרים) ולצאת ממנה אם המשתמש החזיר את התשובה "="
  - כדי לצאת מלולאה באמצע - נשתמש בbreak.
7 שלב בונוס: נסו להוסיף מונה שבודק כמה נסיונות כבר עשיתם ומגביל את המשחק ל10
8 שלב בונוס: נסו לכתוב את המשחק ככה שכאשר הוא מסתיים, יתחיל משחק חדש
  - רמז: אפשר לעשות לולאה בתוך לולאה. 

תרגיל למחשבה - נניח שאנחנו רוצים לבחור מספר בין 1 למליון, כמה ניחושים המחשב יצטרך לכל היותר ? 10, 20, 100 ? משהו באמצע ? 

בהצלחה
